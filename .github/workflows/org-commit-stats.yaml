name: Org Commit Insights (30d summary + weekly LOC default on + 1500d chart)

on:
  workflow_dispatch:
    inputs:
      compute_loc:
        description: "Compute LOC (true/false). Default true."
        required: false
        default: "true"
  schedule:
    - cron: "0 6 * * 1" # every Monday 06:00 UTC

env:
  # Org login for API
  ORG_NAME: Ludo-MVP
  # Display name in report (fixed)
  ORG_LABEL: Ludo Labs AG

permissions:
  contents: write

concurrency:
  group: org-commit-insights
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify gh is available
        run: gh --version

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG_NAME }}

      - name: Install deps (matplotlib always, cloc when LOC enabled)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install matplotlib

          COMPUTE_LOC="true"
          if [[ "${GITHUB_EVENT_NAME}" != "schedule" ]]; then
            COMPUTE_LOC="${{ inputs.compute_loc || 'true' }}"
          fi

          if [[ "${COMPUTE_LOC}" == "true" ]]; then
            sudo apt-get update -y
            sudo apt-get install -y cloc
          fi

      - name: Generate report (Markdown + optional LOC + 1500d chart)
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          ORG_LOGIN: ${{ env.ORG_NAME }}
          ORG_LABEL: ${{ env.ORG_LABEL }}
          SELF_REPO: ${{ github.repository }}
          EVENT_NAME: ${{ github.event_name }}
          COMPUTE_LOC_INPUT: ${{ inputs.compute_loc || 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          # LOC default ON: schedule always true; manual uses input default true
          COMPUTE_LOC="true"
          if [[ "${EVENT_NAME}" != "schedule" ]]; then
            COMPUTE_LOC="${COMPUTE_LOC_INPUT}"
          fi

          OUT_MD="commits.md"
          OUT_PNG="commits_1500d.png"
          DATES_FILE=".commit_dates_1500d.txt"
          ACTIVE_FILE=".active_repos.txt"
          : > "${DATES_FILE}"
          : > "${ACTIVE_FILE}"

          SINCE_30D_ISO="$(date -u -d '30 days ago' +%Y-%m-%dT%H:%M:%SZ)"
          SINCE_30D_DATE="$(date -u -d '30 days ago' +%Y-%m-%d)"
          SINCE_1500D_ISO="$(date -u -d '1500 days ago' +%Y-%m-%dT%H:%M:%SZ)"

          # 1) List repos safely (one per line), no JSON decoding of huge arrays
          mapfile -t REPOS < <(
            gh api "orgs/${ORG_LOGIN}/repos?per_page=100" --paginate \
              --jq '.[] | select(.fork==false and .archived==false) | .full_name' \
              | grep -v -F "${SELF_REPO}" \
              | grep -v -iE '/stats$' \
              | grep -v -i 'backup' \
              || true
          )

          processed=0
          skipped=0
          total_commits=0
          active_repos=0

          total_loc=0
          loc_counted=0
          loc_skipped=0

          # Helper: count commits since date on default branch using REST commits endpoint.
          # Uses per_page=1 and Link rel="last" (page=N) => total N.
          get_commit_count_30d() {
            local repo="$1"
            local since_iso="$2"

            # -i includes headers; body is JSON list
            local resp status headers body last_page
            resp="$(gh api -i "repos/${repo}/commits?since=${since_iso}&per_page=1" 2>/dev/null || true)"
            status="$(printf "%s" "${resp}" | head -n 1 | awk '{print $2}')"

            if [[ "${status}" != "200" ]]; then
              echo ""
              return 1
            fi

            headers="$(printf "%s" "${resp}" | awk 'BEGIN{p=1} /^\r?$/{p=0} {if(p)print}')"
            body="$(printf "%s" "${resp}" | awk 'BEGIN{p=0} /^\r?$/{p=1;next} {if(p)print}')"

            # If Link: ... rel="last" exists, extract page=NUM
            last_page="$(printf "%s\n" "${headers}" | tr -d '\r' | awk -F'[, ]' '
              BEGIN{n=""}
              /rel="last"/{
                for(i=1;i<=NF;i++){
                  if($i ~ /page=[0-9]+/){
                    match($i, /page=[0-9]+/)
                    n=substr($i, RSTART+5, RLENGTH-5)
                  }
                }
              }
              END{print n}
            ')"

            if [[ -n "${last_page}" ]] && [[ "${last_page}" =~ ^[0-9]+$ ]]; then
              echo "${last_page}"
              return 0
            fi

            # No "last" link => either 0 or 1 item (because per_page=1)
            # If body is "[]", count 0 else 1.
            if echo "${body}" | grep -q '^\s*\[\s*\]\s*$'; then
              echo "0"
            else
              echo "1"
            fi
            return 0
          }

          # Helper: LOC for repo (default branch) using shallow clone + cloc
          get_repo_loc() {
            local repo="$1"
            local dir="__repo_tmp_${RANDOM}_${RANDOM}"

            git clone --quiet --depth 1 "https://x-access-token:${GH_TOKEN}@github.com/${repo}.git" "${dir}" || return 1

            local loc
            loc="$(cloc "${dir}" --json --quiet 2>/dev/null | jq -r '.SUM.code // 0' || echo 0)"

            rm -rf "${dir}"
            echo "${loc}"
          }

          # Helper: dump commit dates since 1500d for repo (default branch) to file
          dump_commit_dates_1500d() {
            local repo="$1"
            local since_iso="$2"

            # This prints one ISO date per line (commit.committer.date)
            gh api "repos/${repo}/commits?since=${since_iso}&per_page=100" --paginate \
              --jq '.[].commit.committer.date' 2>/dev/null || true
          }

          # 2) Compute 30d commits and active repos list
          for repo in "${REPOS[@]}"; do
            # Light throttle to be nice to API
            sleep 0.2

            c="$(get_commit_count_30d "${repo}" "${SINCE_30D_ISO}" || true)"
            if [[ -z "${c}" ]] || ! [[ "${c}" =~ ^[0-9]+$ ]]; then
              skipped=$((skipped+1))
              continue
            fi

            processed=$((processed+1))
            total_commits=$((total_commits + c))

            if (( c > 0 )); then
              active_repos=$((active_repos+1))
              echo "${repo}" >> "${ACTIVE_FILE}"

              if [[ "${COMPUTE_LOC}" == "true" ]]; then
                loc="$(get_repo_loc "${repo}" || true)"
                if [[ -z "${loc}" ]] || ! [[ "${loc}" =~ ^[0-9]+$ ]]; then
                  loc_skipped=$((loc_skipped+1))
                else
                  loc_counted=$((loc_counted+1))
                  total_loc=$((total_loc + loc))
                fi
              fi
            fi
          done

          # 3) Collect 1500d commit dates for active repos only
          if [[ -s "${ACTIVE_FILE}" ]]; then
            while IFS= read -r repo; do
              [[ -z "${repo}" ]] && continue
              # Slight throttle; pagination can be heavier
              sleep 0.3
              dump_commit_dates_1500d "${repo}" "${SINCE_1500D_ISO}" >> "${DATES_FILE}"
            done < "${ACTIVE_FILE}"
          fi

          # 4) Build chart from dates file
          cat > __chart.py <<'PY'
          import os
          from datetime import datetime, timedelta, timezone, date
          from collections import defaultdict

          import matplotlib.pyplot as plt

          dates_file = ".commit_dates_1500d.txt"
          out_png = "commits_1500d.png"

          def week_key(d: date) -> str:
            monday = d - timedelta(days=d.weekday())
            return monday.isoformat()

          weekly = defaultdict(int)

          if os.path.exists(dates_file):
            with open(dates_file, "r", encoding="utf-8") as f:
              for line in f:
                s = line.strip()
                if not s:
                  continue
                # Expected ISO like 2026-01-31T12:34:56Z
                try:
                  d = date.fromisoformat(s[:10])
                  weekly[week_key(d)] += 1
                except Exception:
                  pass

          end_dt = datetime.now(timezone.utc)
          start_dt = end_dt - timedelta(days=1500)
          end_date = end_dt.date()
          start_date = start_dt.date()

          start_monday = start_date - timedelta(days=start_date.weekday())
          end_monday = end_date - timedelta(days=end_date.weekday())

          labels = []
          values = []
          cur = start_monday
          while cur <= end_monday:
            k = cur.isoformat()
            labels.append(k)
            values.append(int(weekly.get(k, 0)))
            cur += timedelta(days=7)

          plt.figure(figsize=(12, 4))
          plt.plot(range(len(values)), values)

          step = max(1, len(labels) // 12)
          plt.xticks(
            range(0, len(labels), step),
            [labels[i] for i in range(0, len(labels), step)],
            rotation=45,
            ha="right"
          )
          plt.ylabel("Commits (weekly)")
          title = "Org commits trend (last 1500 days, weekly, active repos, default branches)"
          if sum(values) == 0:
            title = "Org commits (last 1500 days) â€” no data"
          plt.title(title)
          plt.tight_layout()
          plt.savefig(out_png, dpi=150)
          PY

          python __chart.py
          rm -f __chart.py

          # 5) Write markdown (no per-repo stats)
          {
            echo "# Organization Commit Insights"
            echo
            echo "**Org:** ${ORG_LABEL}  "
            echo "**Commits period:** last 30 days (since ${SINCE_30D_DATE}, default branches)  "
            if [[ "${COMPUTE_LOC}" == "true" ]]; then
              echo "**LOC:** computed weekly for repos with commits > 0  "
            else
              echo "**LOC:** not computed  "
            fi
            echo "**Generated:** $(date -u +"%Y-%m-%d %H:%M UTC")"
            echo
            echo "## Summary"
            echo "- **Total commits (30d):** ${total_commits}"
            echo "- **Repositories counted (commits):** ${processed}"
            echo "- **Repositories skipped (commits):** ${skipped}"
            echo "- **Active repos (commits > 0):** ${active_repos}"
            echo "- **Total LOC (active repos only):** ${total_loc}"
            echo "- **Repositories counted (LOC):** ${loc_counted}"
            echo "- **Repositories skipped (LOC):** ${loc_skipped}"
            echo
            echo "![Org commits trend (last 1500 days)](${OUT_PNG})"
          } > "${OUT_MD}"

          # Cleanup transient files (keep chart + md only)
          rm -f "${DATES_FILE}" "${ACTIVE_FILE}"

      - name: Commit & push report
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "actions@github.com"

          git add commits.md commits_1500d.png || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "Update org commit insights (30d summary + LOC + 1500d chart)"
          git push
