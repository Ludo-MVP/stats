name: Org Commit Insights (30d summary + weekly LOC default on + 1500d chart)

on:
  workflow_dispatch:
    inputs:
      compute_loc:
        description: "Compute LOC (true/false). Default true."
        required: false
        default: "true"
  schedule:
    - cron: "0 6 * * 1" # every Monday 06:00 UTC

# ORG_NAME is the org login used for API (not display name)
env:
  ORG_NAME: Ludo-MVP

permissions:
  contents: write

concurrency:
  group: org-commit-insights
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify gh is available
        run: gh --version

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG_NAME }}

      - name: Install deps (charts always, cloc when LOC enabled)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install matplotlib

          # LOC default ON: schedule always true; manual uses input default true
          COMPUTE_LOC="true"
          if [[ "${GITHUB_EVENT_NAME}" != "schedule" ]]; then
            COMPUTE_LOC="${{ inputs.compute_loc || 'true' }}"
          fi

          if [[ "${COMPUTE_LOC}" == "true" ]]; then
            sudo apt-get update -y
            sudo apt-get install -y cloc
          fi

      - name: Generate Markdown summary + optional LOC (default on)
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        shell: bash
        run: |
          set -euo pipefail

          ORG_LOGIN="${ORG_NAME}"          # for API (org login)
          ORG_LABEL="Ludo Labs AG"         # report display name (fixed)
          OUT="commits.md"
          SINCE="$(date -u -d '30 days ago' +%Y-%m-%d)"

          # LOC default ON: schedule always true; manual uses input default true
          COMPUTE_LOC="true"
          if [[ "${GITHUB_EVENT_NAME}" != "schedule" ]]; then
            COMPUTE_LOC="${{ inputs.compute_loc || 'true' }}"
          fi

          SELF_REPO="${GITHUB_REPOSITORY}"

          mapfile -t REPOS < <(
            gh api "orgs/${ORG_LOGIN}/repos?per_page=100" --paginate \
              --jq '.[] | select(.fork==false and .archived==false) | .full_name' \
            | grep -v -F "${SELF_REPO}" \
            | grep -vi 'backup' || true
          )

          total_commits=0
          processed=0
          skipped=0
          active_repos=0

          total_loc=0
          loc_counted=0
          loc_skipped=0

          ACTIVE_FILE=".active_repos.txt"
          : > "${ACTIVE_FILE}"

          get_repo_commit_count() {
            local repo="$1"
            local since="$2"
            local tries=0
            local max_tries=6

            while (( tries < max_tries )); do
              tries=$((tries+1))

              local resp status body
              resp="$(gh api -i -H "Accept: application/vnd.github.cloak-preview+json" \
                "/search/commits?q=repo:${repo}+committer-date:>=${since}&per_page=1" 2>/dev/null || true)"

              status="$(printf "%s" "$resp" | head -n 1 | awk '{print $2}')"
              body="$(printf "%s" "$resp" | awk 'BEGIN{p=0} /^\r?$/{p=1;next} {if(p)print}')"

              if [[ "$status" == "200" ]]; then
                echo "$body" | jq -r '.total_count // 0' 2>/dev/null || echo 0
                return 0
              fi

              if [[ "$status" == "403" ]]; then
                sleep $((10 * tries))
                continue
              fi

              echo ""
              return 1
            done

            echo ""
            return 1
          }

          get_repo_loc() {
            local repo="$1"
            local dir="__repo_tmp_${RANDOM}_${RANDOM}"

            git clone --quiet --depth 1 "https://x-access-token:${GH_TOKEN}@github.com/${repo}.git" "${dir}" || return 1

            local loc
            loc="$(cloc "${dir}" --json --quiet 2>/dev/null | jq -r '.SUM.code // 0' || echo 0)"

            rm -rf "${dir}"
            echo "${loc}"
          }

          # throttle: Search commits is rate-limited
          for repo in "${REPOS[@]}"; do
            sleep 2.2

            c="$(get_repo_commit_count "${repo}" "${SINCE}" || true)"
            if [[ -z "${c}" ]] || ! [[ "${c}" =~ ^[0-9]+$ ]]; then
              skipped=$((skipped+1))
              continue
            fi

            processed=$((processed+1))
            total_commits=$((total_commits + c))

            if (( c > 0 )); then
              active_repos=$((active_repos+1))
              echo "${repo}" >> "${ACTIVE_FILE}"

              if [[ "${COMPUTE_LOC}" == "true" ]]; then
                loc="$(get_repo_loc "${repo}" || true)"
                if [[ -z "${loc}" ]] || ! [[ "${loc}" =~ ^[0-9]+$ ]]; then
                  loc_skipped=$((loc_skipped+1))
                else
                  loc_counted=$((loc_counted+1))
                  total_loc=$((total_loc + loc))
                fi
              fi
            fi
          done

          {
            echo "# Organization Commit Insights"
            echo
            echo "**Org:** ${ORG_LABEL}  "
            echo "**Commits period:** last 30 days (since ${SINCE}, all branches)  "
            echo "**LOC:** $([[ "${COMPUTE_LOC}" == "true" ]] && echo "computed weekly for repos with commits > 0" || echo "not computed")  "
            echo "**Generated:** $(date -u +"%Y-%m-%d %H:%M UTC")"
            echo
            echo "## Summary"
            echo "- **Total commits (30d):** ${total_commits}"
            echo "- **Repositories counted (commits):** ${processed}"
            echo "- **Repositories skipped (commits):** ${skipped}"
            echo "- **Active repos (commits > 0):** ${active_repos}"
            echo "- **Total LOC (active repos only):** ${total_loc}"
            echo "- **Repositories counted (LOC):** ${loc_counted}"
            echo "- **Repositories skipped (LOC):** ${loc_skipped}"
            echo
            echo "![Org commits trend (last 1500 days)](commits_1500d.png)"
          } > "${OUT}"

          echo "Summary written to ${OUT}"

      - name: Generate 1500-day chart (weekly bins, active repos, default branches)
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        shell: bash
        run: |
          set -euo pipefail

          ACTIVE_FILE=".active_repos.txt"
          OUT_PNG="commits_1500d.png"

          # If no active repos, write minimal chart and exit
          if [[ ! -s "${ACTIVE_FILE}" ]]; then
            cat > __chart_empty.py <<'PY'
            import matplotlib.pyplot as plt
            plt.figure(figsize=(12,4))
            plt.plot([0],[0])
            plt.title("Org commits (last 1500 days) â€” no active repos")
            plt.tight_layout()
            plt.savefig("commits_1500d.png", dpi=150)
            PY
            python __chart_empty.py
            rm -f __chart_empty.py
            exit 0
          fi

          # Generate chart script (avoid heredoc into python to prevent EOF issues)
          cat > __chart_1500d.py <<'PY'
          import json
          import subprocess
          from datetime import datetime, timedelta, timezone, date
          from collections import defaultdict
          
          out_png = "commits_1500d.png"
          
          end_dt = datetime.now(timezone.utc)
          start_dt = end_dt - timedelta(days=1500)
          since_iso = start_dt.isoformat().replace("+00:00", "Z")
          
          with open(".active_repos.txt", "r", encoding="utf-8") as f:
            repos = [line.strip() for line in f.read().splitlines() if line.strip()]
          
          def gh_graphql(query: str, variables: dict):
            out = subprocess.check_output(
              ["gh", "api", "graphql", "-f", f"query={query}", "-f", f"variables={json.dumps(variables)}"],
              text=True
            )
            return json.loads(out)
          
          q = r"""
          query($owner:String!, $name:String!, $since:GitTimestamp!) {
            repository(owner:$owner, name:$name) {
              defaultBranchRef {
                target {
                  ... on Commit {
                    history(since:$since, first:100) {
                      pageInfo { hasNextPage endCursor }
                      nodes { committedDate }
                    }
                  }
                }
              }
            }
          }
          """
          
          q_page = r"""
          query($owner:String!, $name:String!, $since:GitTimestamp!, $after:String!) {
            repository(owner:$owner, name:$name) {
              defaultBranchRef {
                target {
                  ... on Commit {
                    history(since:$since, first:100, after:$after) {
                      pageInfo { hasNextPage endCursor }
                      nodes { committedDate }
                    }
                  }
                }
              }
            }
          }
          """
          
          weekly = defaultdict(int)
          
          def week_key(d: date) -> str:
            monday = d - timedelta(days=d.weekday())
            return monday.isoformat()
          
          def add_repo(owner: str, name: str):
            data = gh_graphql(q, {"owner": owner, "name": name, "since": since_iso})
            repo = (((data.get("data") or {}).get("repository")) or {})
            dbr = repo.get("defaultBranchRef")
            if not dbr:
              return
            target = dbr.get("target") or {}
            hist = (target.get("history") or {})
            nodes = hist.get("nodes") or []
          
            for n in nodes:
              cd = n.get("committedDate")
              if cd:
                d = date.fromisoformat(cd[:10])
                weekly[week_key(d)] += 1
          
            pi = hist.get("pageInfo") or {}
            after = pi.get("endCursor")
            while pi.get("hasNextPage"):
              data2 = gh_graphql(q_page, {"owner": owner, "name": name, "since": since_iso, "after": after})
              repo2 = (((data2.get("data") or {}).get("repository")) or {})
              dbr2 = repo2.get("defaultBranchRef")
              if not dbr2:
                break
              target2 = dbr2.get("target") or {}
              hist2 = (target2.get("history") or {})
              nodes2 = hist2.get("nodes") or []
              for n in nodes2:
                cd = n.get("committedDate")
                if cd:
                  d = date.fromisoformat(cd[:10])
                  weekly[week_key(d)] += 1
              pi = hist2.get("pageInfo") or {}
              after = pi.get("endCursor")
          
          for full in repos:
            if "/" not in full:
              continue
            owner, name = full.split("/", 1)
            add_repo(owner, name)
          
          end_date = end_dt.date()
          start_date = start_dt.date()
          
          start_monday = start_date - timedelta(days=start_date.weekday())
          end_monday = end_date - timedelta(days=end_date.weekday())
          
          labels = []
          values = []
          cur = start_monday
          while cur <= end_monday:
            k = cur.isoformat()
            labels.append(k)
            values.append(int(weekly.get(k, 0)))
            cur += timedelta(days=7)
          
          import matplotlib.pyplot as plt
          plt.figure(figsize=(12,4))
          plt.plot(range(len(values)), values)
          
          step = max(1, len(labels)//12)
          plt.xticks(
            range(0, len(labels), step),
            [labels[i] for i in range(0, len(labels), step)],
            rotation=45,
            ha="right"
          )
          plt.ylabel("Commits (weekly)")
          plt.title("Org commits trend (last 1500 days, weekly, active repos, default branches)")
          plt.tight_layout()
          plt.savefig(out_png, dpi=150)
          PY

          python __chart_1500d.py
          rm -f __chart_1500d.py

      - name: Commit & push report
        shell: bash
        run: |
          set -euo pipefail

          git config user.name "github-actions"
          git config user.email "actions@github.com"

          # Commit only report artifacts (do NOT commit temp files)
          git add commits.md commits_1500d.png || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
            rm -f .active_repos.txt
            exit 0
          fi

          git commit -m "Update org commit insights (30d summary + LOC + 1500d chart)"
          git push

          # Cleanup temp file
          rm -f .active_repos.txt
